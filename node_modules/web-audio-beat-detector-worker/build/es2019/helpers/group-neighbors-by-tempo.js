export const groupNeighborsByTempo = (intervalBuckets, sampleRate, tempoSettings = {}) => {
    var _a, _b;
    const minTempo = Math.max(0, (_a = tempoSettings.minTempo) !== null && _a !== void 0 ? _a : 90);
    const maxTempo = Math.max(0, (_b = tempoSettings.maxTempo) !== null && _b !== void 0 ? _b : 180);
    const tempoBuckets = [];
    intervalBuckets.forEach((intervalBucket) => {
        // Convert an interval to a tempo (aka BPM).
        let theoreticalTempo = 60 / (intervalBucket.interval / sampleRate);
        // Adjust the tempo to fit within the min-max (90-180) BPM range.
        while (theoreticalTempo < minTempo) {
            theoreticalTempo *= 2;
        }
        while (theoreticalTempo > maxTempo) {
            theoreticalTempo /= 2;
        }
        let foundTempo = false;
        let score = intervalBucket.peaks.length;
        tempoBuckets.forEach((tempoBucket) => {
            if (tempoBucket.tempo === theoreticalTempo) {
                tempoBucket.score += intervalBucket.peaks.length;
                tempoBucket.peaks = [...tempoBucket.peaks, ...intervalBucket.peaks];
                foundTempo = true;
            }
            if (tempoBucket.tempo > theoreticalTempo - 0.5 && tempoBucket.tempo < theoreticalTempo + 0.5) {
                const tempoDifference = Math.abs(tempoBucket.tempo - theoreticalTempo) * 2;
                score += (1 - tempoDifference) * tempoBucket.peaks.length;
                tempoBucket.score += (1 - tempoDifference) * intervalBucket.peaks.length;
            }
        });
        if (!foundTempo) {
            tempoBuckets.push({
                peaks: intervalBucket.peaks,
                score,
                tempo: theoreticalTempo
            });
        }
    });
    return tempoBuckets;
};
//# sourceMappingURL=group-neighbors-by-tempo.js.map