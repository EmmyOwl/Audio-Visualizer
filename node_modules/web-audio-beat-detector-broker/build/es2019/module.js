import { addUniqueNumber } from 'fast-unique-numbers';
import { isSupported } from 'standardized-audio-context';
import { render } from './helpers/render';
export { isSupported };
export const load = (url) => {
    const worker = new Worker(url);
    const ongoingRecordingRequests = new Set();
    const analyze = (audioBuffer, offset = 0, duration = audioBuffer.duration - offset) => {
        return new Promise(async (resolve, reject) => {
            const { channelData, sampleRate } = await render(audioBuffer, offset, duration);
            const id = addUniqueNumber(ongoingRecordingRequests);
            const onMessage = ({ data }) => {
                if (data.id === id) {
                    ongoingRecordingRequests.delete(id);
                    worker.removeEventListener('message', onMessage);
                    if (data.error === null) {
                        resolve(data.result.tempo);
                    }
                    else {
                        reject(new Error(data.error.message));
                    }
                }
            };
            worker.addEventListener('message', onMessage);
            worker.postMessage({ id, method: 'analyze', params: { channelData, sampleRate } }, [
                channelData.buffer
            ]);
        });
    };
    const guess = (audioBuffer, offset = 0, duration = audioBuffer.duration - offset) => {
        return new Promise(async (resolve, reject) => {
            const { channelData, sampleRate } = await render(audioBuffer, offset, duration);
            const id = addUniqueNumber(ongoingRecordingRequests);
            const onMessage = ({ data }) => {
                if (data.id === id) {
                    ongoingRecordingRequests.delete(id);
                    worker.removeEventListener('message', onMessage);
                    if (data.error === null) {
                        resolve(data.result);
                    }
                    else {
                        reject(new Error(data.error.message));
                    }
                }
            };
            worker.addEventListener('message', onMessage);
            worker.postMessage({ id, method: 'guess', params: { channelData, sampleRate } }, [
                channelData.buffer
            ]);
        });
    };
    return {
        analyze,
        guess
    };
};
//# sourceMappingURL=module.js.map