(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@babel/runtime/helpers/toConsumableArray')) :
    typeof define === 'function' && define.amd ? define(['@babel/runtime/helpers/toConsumableArray'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global._toConsumableArray));
})(this, (function (_toConsumableArray) { 'use strict';

    var countIntervalsBetweenNearbyPeaks = function countIntervalsBetweenNearbyPeaks(peaks) {
      var intervalBuckets = [];
      peaks.forEach(function (peak, index) {
        var length = Math.min(peaks.length - index, 10);
        var _loop = function _loop() {
          var interval = peaks[index + i] - peak;
          var foundInterval = intervalBuckets.some(function (intervalBucket) {
            if (intervalBucket.interval === interval) {
              intervalBucket.peaks.push(peak);
              return true;
            }
            return false;
          });
          if (!foundInterval) {
            intervalBuckets.push({
              interval: interval,
              peaks: [peak]
            });
          }
        };
        for (var i = 1; i < length; i += 1) {
          _loop();
        }
      });
      return intervalBuckets;
    };

    var getMaximumValue = function getMaximumValue(channelData) {
      var maximumValue = 0;
      var length = channelData.length;
      for (var i = 0; i < length; i += 1) {
        if (channelData[i] > maximumValue) {
          maximumValue = channelData[i];
        }
      }
      return maximumValue;
    };

    var getPeaksAtThreshold = function getPeaksAtThreshold(channelData, threshold, sampleRate) {
      var length = channelData.length;
      var peaks = [];
      var lastValueWasAboveThreshold = false;
      for (var i = 0; i < length; i += 1) {
        if (channelData[i] > threshold) {
          lastValueWasAboveThreshold = true;
        } else if (lastValueWasAboveThreshold) {
          lastValueWasAboveThreshold = false;
          peaks.push(i - 1);
          // Skip 0.25 seconds forward to get past this peak.
          i += sampleRate / 4 - 1;
        }
      }
      // Add the last value in the unlikely case it was peak.
      if (lastValueWasAboveThreshold) {
        peaks.push(length - 1);
      }
      return peaks;
    };

    var groupNeighborsByTempo = function groupNeighborsByTempo(intervalBuckets, sampleRate) {
      var tempoSettings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var _a, _b;
      var minTempo = Math.max(0, (_a = tempoSettings.minTempo) !== null && _a !== void 0 ? _a : 90);
      var maxTempo = Math.max(0, (_b = tempoSettings.maxTempo) !== null && _b !== void 0 ? _b : 180);
      var tempoBuckets = [];
      intervalBuckets.forEach(function (intervalBucket) {
        // Convert an interval to a tempo (aka BPM).
        var theoreticalTempo = 60 / (intervalBucket.interval / sampleRate);
        // Adjust the tempo to fit within the min-max (90-180) BPM range.
        while (theoreticalTempo < minTempo) {
          theoreticalTempo *= 2;
        }
        while (theoreticalTempo > maxTempo) {
          theoreticalTempo /= 2;
        }
        var foundTempo = false;
        var score = intervalBucket.peaks.length;
        tempoBuckets.forEach(function (tempoBucket) {
          if (tempoBucket.tempo === theoreticalTempo) {
            tempoBucket.score += intervalBucket.peaks.length;
            tempoBucket.peaks = [].concat(_toConsumableArray(tempoBucket.peaks), _toConsumableArray(intervalBucket.peaks));
            foundTempo = true;
          }
          if (tempoBucket.tempo > theoreticalTempo - 0.5 && tempoBucket.tempo < theoreticalTempo + 0.5) {
            var tempoDifference = Math.abs(tempoBucket.tempo - theoreticalTempo) * 2;
            score += (1 - tempoDifference) * tempoBucket.peaks.length;
            tempoBucket.score += (1 - tempoDifference) * intervalBucket.peaks.length;
          }
        });
        if (!foundTempo) {
          tempoBuckets.push({
            peaks: intervalBucket.peaks,
            score: score,
            tempo: theoreticalTempo
          });
        }
      });
      return tempoBuckets;
    };

    var MINUMUM_NUMBER_OF_PEAKS = 30;
    var computeTempoBuckets = function computeTempoBuckets(channelData, sampleRate, tempoSettings) {
      var maximumValue = getMaximumValue(channelData);
      var minimumThreshold = maximumValue * 0.3;
      var peaks = [];
      var threshold = maximumValue - maximumValue * 0.05;
      if (maximumValue > 0.25) {
        while (peaks.length < MINUMUM_NUMBER_OF_PEAKS && threshold >= minimumThreshold) {
          peaks = getPeaksAtThreshold(channelData, threshold, sampleRate);
          threshold -= maximumValue * 0.05;
        }
      }
      var intervalBuckets = countIntervalsBetweenNearbyPeaks(peaks);
      var tempoBuckets = groupNeighborsByTempo(intervalBuckets, sampleRate, tempoSettings);
      tempoBuckets.sort(function (a, b) {
        return b.score - a.score;
      });
      return tempoBuckets;
    };

    var analyze = function analyze(channelData, sampleRate, tempoSettings) {
      var tempoBuckets = computeTempoBuckets(channelData, sampleRate, tempoSettings);
      if (tempoBuckets.length === 0) {
        throw new Error('The given channelData does not contain any detectable beats.');
      }
      return tempoBuckets[0].tempo;
    };

    var guess = function guess(channelData, sampleRate, tempoSettings) {
      var tempoBuckets = computeTempoBuckets(channelData, sampleRate, tempoSettings);
      if (tempoBuckets.length === 0) {
        throw new Error('The given channelData does not contain any detectable beats.');
      }
      var _tempoBuckets$ = tempoBuckets[0],
        peaks = _tempoBuckets$.peaks,
        tempo = _tempoBuckets$.tempo;
      var bpm = Math.round(tempo);
      var secondsPerBeat = 60 / bpm;
      peaks.sort(function (a, b) {
        return a - b;
      });
      var offset = peaks[0] / sampleRate;
      while (offset > secondsPerBeat) {
        offset -= secondsPerBeat;
      }
      return {
        bpm: bpm,
        offset: offset,
        tempo: tempo
      };
    };

    addEventListener('message', function (_ref) {
      var data = _ref.data;
      try {
        if (data.method === 'analyze') {
          var id = data.id,
            _data$params = data.params,
            channelData = _data$params.channelData,
            sampleRate = _data$params.sampleRate,
            tempoSettings = _data$params.tempoSettings;
          var tempo = analyze(channelData, sampleRate, tempoSettings);
          postMessage({
            error: null,
            id: id,
            result: {
              tempo: tempo
            }
          });
        } else if (data.method === 'guess') {
          var _id = data.id,
            _data$params2 = data.params,
            _channelData = _data$params2.channelData,
            _sampleRate = _data$params2.sampleRate,
            _tempoSettings = _data$params2.tempoSettings;
          var _guess = guess(_channelData, _sampleRate, _tempoSettings),
            bpm = _guess.bpm,
            offset = _guess.offset,
            _tempo = _guess.tempo;
          postMessage({
            error: null,
            id: _id,
            result: {
              bpm: bpm,
              offset: offset,
              tempo: _tempo
            }
          });
        } else {
          throw new Error("The given method \"".concat(data.method, "\" is not supported"));
        }
      } catch (err) {
        postMessage({
          error: {
            message: err.message
          },
          id: data.id,
          result: null
        });
      }
    });

}));
